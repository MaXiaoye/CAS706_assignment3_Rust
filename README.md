# CAS706_assignment3_Rust

Assignment 3
Typed Lambda-calculus interpreter.
Your term language should be based on the same term language as A2. The operational semantics is the same as for A2, and the same as in the textbook.

You should first write down the typing rules for your language. You are allowed, even highly encouraged, to improve the A2 grammar to make your life easier, so that typing rules can be made simpler. Your task is to have your interpreter first do type reconstruction for all inputs before any reduction is done. Decent error messages should be returned for untypable terms. The interpreter should then proceed as in assignment 2.

You should also be providing some test cases for your interpreter - make sure to test higher-order functions as well as cases that do not type (such as old stuck cases from assignment 2) and cases that work but are rejected in your typed language.

You should try to leverage the host system as much as you can for this assignment. This can mean having the type inference algorithm return a typed term, from a different ADT, than the original source. Then your interpreter can be much much simpler (and it should be) because all the 'impossible' cases have been removed already.

In other words, you are writing a type inference routine as the most important part of this assignment. The unification algorithm is thus key.

Bonus: implement an interpreter for your language but using the finally tagless method (in whatever language you want, but this is easiest in Haskell/Scala/Ocaml; more bonus for more languages. Can even be done in Agda/Idris). Note that this is cheating, in the sense that even though it is typed, the types are maintained by the host language, so that there is no need to implement unification (or even a separate typing pass) at all!

-------------------------------------

I consider I implement type inference well :) , including
I implement type inference by the same procedure for all 4 languages:

Untyped terms --> typed terms --> constraints set --> solutions set

Main functions between above sections: 
Untyped terms --> typed terms : annotate( ) / reconstruct( )
typed terms --> constraints set : collect( )
constraints set --> solutions set : unify( )

Such that:
let TypedTerm = annotate(term, EnvT, &mut 0);
	    let Constraints = collect(TypedTerm.clone());
	    let solutions = unify(Constraints);
solutions.applyOneType(TypedTerm.clone().getType())

!!!Here, TypedTerm can be changed to any sub term in it. That means we can get the type of any sub term from solution set by using applyOneType().

Usage:
Just run src/main.rs

Example \y.\x. x+y
//i1 is int 5
	let i1 = UntypedTerm::INT{value: 5};
	//b1 is bool true
	let b1 = UntypedTerm::BOOL{value: true};
	//c3 is calc x+y
	let c2 = UntypedTerm::CALC{op: '+',exp1: Box::new(UntypedTerm::VAR{name: 'y'}),exp2: Box::new(UntypedTerm::VAR{name: 'x'})};
	//f2 is \x. x+y
	let f2 = UntypedTerm::FUN{param: 'x', body: Box::new(c2)};
	//f3 is \y.\x. x+y
	let f3 = UntypedTerm::FUN{param: 'y', body: Box::new(f2)};
	//a2 is application (\y.\x. x+y) 5
	let a2 = UntypedTerm::APP{fun: Box::new(f3.clone()), arg: Box::new(i1.clone())};
	//a3 is application ((\y.\x. x+y)5)5
	Let a3 = UntypedTerm::APP{fun: Box::new(a2.clone()), arg: Box::new(i1.clone())};

//typeInference return the whole solution set and type of a term.
//in this case, f3 is \y.\x. x+y, so type of f3 is "TyFun { ParamTy: TyInt, ReturnTy: TyFun { ParamTy: TyInt, ReturnTy: TyInt } }", which is No.2 in solutions set
//that means f3 is function takes an int, return a funtion2. Function2 takes an int and returns an int.
	println!("Type inference for \\y.\\x. x+y:");
typeInference(f3.clone()); <-- f3 can be changed by other terms
//InterpE do type inference firstly, if it is well-typed then print return type and do interpretation.
    println!("Interpretation for ((\\y.\\x. x+y)5)5:");
    InterpE(a3);

Test cases:

Num (1 2 3 etc..) in solutions set are anonymous types for all sub terms (t1 t2 t3 etc...) generated by type reconstruction function annotate( ).

1.
Type inference for \y.\x. x+y:
Solution set is:
Substitution { solutions: {4: TyFun { ParamTy: TyInt, ReturnTy: TyInt }, 3: TyInt, 5: TyInt, 1: TyInt, 2: TyFun { ParamTy: TyInt, ReturnTy: TyFun { ParamTy: TyInt, ReturnTy: TyInt } }} }
 
Type of target term is:
TyFun { ParamTy: TyInt, ReturnTy: TyFun { ParamTy: TyInt, ReturnTy: TyInt } }
 
Interpretation for ((\y.\x. x+y)5)5:
Interpretation result:
T_INT { ty: TyInt, value: 10 }
 
2.
Type inference for let x=5 in x==5? :
Solution set is:
Substitution { solutions: {2: TyBool, 1: TyInt, 3: TyInt, 4: TyBool, 5: TyInt} }
 
Type of target term is:
TyBool
 
Interpretation for let x=5 in x==5?:
Interpretation result:
T_BOOL { ty: TyBool, value: true }

3.
//in this case, f4 is identity function \x. x, so type of f4 is "TyFun { ParamTy: TyVar { num: 1 }, ReturnTy: TyVar { num: 1 } }"
//that means f4 is function takes a param type t1, returns the same type t1.
Type inference for \x.x :
Solution set is:
Substitution { solutions: {2: TyFun { ParamTy: TyVar { num: 1 }, ReturnTy: TyVar { num: 1 } }} }
 
4.
Type of target term is:
TyFun { ParamTy: TyVar { num: 1 }, ReturnTy: TyVar { num: 1 } }
 
//in this case, try to apply a bool value to an arithmetic exp.
//It panic because of "cannot unify"
Type inference for ((\y.\x. x+y)5)true:
thread 'main' panicked at 'cannot unify', src\main.rs:349:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
